# Выполнение домашних заданий по PYTON.
## 1. Клонируйте репозиторий:
```
git clone https://github.com/GrachevAleksandr/DZ_9
```
## 2. Установите зависимости:
```
pip install -r requirements.txt
```

## Лицензия:
Этот проект лицензирован по [лицензии MIT](`LICENSE`).
```
Контекст
IT-отдел крупного банка делает новую фичу для личного кабинета клиента. Это виджет, который показывает несколько 
последних успешных банковских операций клиента. Вам доверили реализовать этот проект, который на бэкенде будет 
готовить данные для отображения в новом виджете.
Вы будете работать над проектом на протяжении всех домашних заданий этого курса.
```
# 9_1.
## **Задачи**
### 1. Организуйте ваш проект — создайте основные пакеты:`src`— для исходного кода,`tests`— для тестов.
### 2. Установите инструменты для проверки качества кода (`Flake8`,`black`,`isort`,`mypy`) в группу`lint`через`Poetry`.
### 3. Настройте файл`.flake8`для конфигурации линтера `Flake8`. 
### 4. Добавьте конфигурации для `black`,`isort` и`mypy`в файл`pyproject.toml`.
### 5. В пакете`src`создайте модуль с названием`masks`.
### 6. Реализуйте в этом модуле две функции:
- Функцию маскировки номера банковской карты`get_mask_card_number`.
- Функцию маскировки номера банковского счета `get_mask_account`.

## Как работают эти функции
- Функция `get_mask_card_number`принимает на вход номер карты и возвращает ее маску. 
Номер карты замаскирован и отображается в формате `XXXX XX** **** XXXX`, где `X`— это цифра номера. 
То есть видны первые 6 цифр и последние 4 цифры, остальные символы отображаются звездочками, 
номер разбит по блокам по 4 цифры, разделенным пробелами. Пример работы функции:
```
7000792289606361     # входной аргумент
7000 79** **** 6361  # выход функции
```
- Функция `get_mask_account`принимает на вход номер счета и возвращает его маску. 
Номер счета замаскирован и отображается в формате`**XXXX`, где `X`— это цифра номера. 
То есть видны только последние 4 цифры номера, а перед ними — две звездочки. Пример работы функции:
```
73654108430135874305  # входной аргумент
**4305  # выход функции
```
### 7. Запустите линтер Flake8 для проверки стиля кода.
### 8. Используйте`black`и`isort`для форматирования кода.
### 9. Проведите статический анализ типов с помощью`mypy`, чтобы убедиться в отсутствии ошибок типизации в коде.
# 9_2.
### 1. Инициализируйте новый локальный Git-репозиторий в папке проекта, используя команду `git init`.
### 2. Создайте файл .gitignore в корне проекта и добавьте в него стандартные шаблоны для Python, чтобы исключить системные и временные файлы, такие как __pycache__, .idea и другие. Для заполнения файла можете воспользоваться шаблоном.
### 3. Сделайте минимум три `коммита` в процессе разработки кода, фиксируя основные этапы создания вашего проекта. Например, первый коммит может быть фиксацией прогресса по прошлой `домашке`, второй — добавлением новых функций, третий — финальными изменениями и доработками.
### 4. В пакете `src` создайте новый модуль с именем `widget`. Этот модуль будет содержать функции для работы с новыми возможностями приложения.
### 5. В модуле `widget` создайте функцию `mask_account_card`,которая умеет обрабатывать информацию как о картах, так и о счетах.
```
Функция должна:
Принимать один аргумент — строку, содержащую тип и номер карты или счета.
Аргументом может быть строка типа 
Visa Platinum 7000792289606361, или Maestro 7000792289606361, или Счет 73654108430135874305. 
Разделять строку на 2 аргумента (отдельно имя, отдельно номер) нельзя!
Возвращать строку с замаскированным номером. Для карт и счетов используйте разные типы маскировки.
Переиспользуйте уже существующие функции маскировки из вашего проекта, чтобы избежать дублирования кода.
```
### 6. В том же модуле создайте функцию `get_date`, которая принимает на вход строку с датой в формате`"2024-03-11T02:26:18.671407"`и возвращает строку с датой в формате "ДД.ММ.ГГГГ" ("11.03.2024").
# 10_1.
### 1. Создайте новые ветки в вашем репозитории для работы по GitFlow.
### 2. Создайте новый репозиторий на GitHub, который будет использоваться для хранения и совместной работы над вашим проектом.
### 3. Залейте содержимое вашего локального репозитория в созданный репозиторий на GitHub, используя команды `git add`,`git commit`и `git push`.
### 4. В директории `src`вашего проекта создайте модуль `processing`, который будет содержать новые функции обработки данных.
### 5. В модуле `processing`напишите функцию `filter_by_state`, которая принимает список словарей и опционально значение для ключа `state`(по умолчанию 'EXECUTED'). Функция возвращает новый список словарей, содержащий только те словари, у которых ключ `state` соответствует указанному значению.
```
Примеры работы функции
# Выход функции со статусом по умолчанию 'EXECUTED'
[{'id': 41428829, 'state': 'EXECUTED', 'date': '2019-07-03T18:35:29.512364'}, 
{'id': 939719570, 'state': 'EXECUTED', 'date': '2018-06-30T02:08:58.425572'}]

# Выход функции, если вторым аргументов передано 'CANCELED'
[{'id': 594226727, 'state': 'CANCELED', 'date': '2018-09-12T21:27:25.241689'}, 
{'id': 615064591, 'state': 'CANCELED', 'date': '2018-10-14T08:21:33.419441'}]
```
```
Пример входных данных для проверки функции
[{'id': 41428829, 'state': 'EXECUTED', 'date': '2019-07-03T18:35:29.512364'}, 
{'id': 939719570, 'state': 'EXECUTED', 'date': '2018-06-30T02:08:58.425572'}, 
{'id': 594226727, 'state': 'CANCELED', 'date': '2018-09-12T21:27:25.241689'}, 
{'id': 615064591, 'state': 'CANCELED', 'date': '2018-10-14T08:21:33.419441'}]
```
### 6. В том же модуле напишите функцию `sort_by_date`, которая принимает список словарей и необязательный параметр, задающий порядок сортировки (по умолчанию — убывание). Функция должна возвращать новый список, отсортированный по дате (`date`).
```
Примеры работы функции
# Выход функции (сортировка по убыванию, т. е. сначала самые последние операции)
[{'id': 41428829, 'state': 'EXECUTED', 'date': '2019-07-03T18:35:29.512364'}, 
{'id': 615064591, 'state': 'CANCELED', 'date': '2018-10-14T08:21:33.419441'}, 
{'id': 594226727, 'state': 'CANCELED', 'date': '2018-09-12T21:27:25.241689'}, 
{'id': 939719570, 'state': 'EXECUTED', 'date': '2018-06-30T02:08:58.425572'}]
```
```
Пример входных данных для проверки функции
[{'id': 41428829, 'state': 'EXECUTED', 'date': '2019-07-03T18:35:29.512364'}, 
{'id': 939719570, 'state': 'EXECUTED', 'date': '2018-06-30T02:08:58.425572'}, 
{'id': 594226727, 'state': 'CANCELED', 'date': '2018-09-12T21:27:25.241689'}, 
{'id': 615064591, 'state': 'CANCELED', 'date': '2018-10-14T08:21:33.419441'}]
```
### 7. Создайте README-файл для вашего проекта, в котором описаны цель проекта, инструкции по установке и использованию разработанных функций, примеры работы с ними.

# 10_2.
```
Не забудьте, что мы работаем по GitFlow. Необходимо создать новую ветку от актуальной версии ветки 
разработки и выполнять задания в ней.
```
### 1. Используйте библиотеку `pytest` и напишите тесты для существующего кода проекта.
### Ниже приведены примеры тест-кейсов. Вы можете использовать их или реализовать свои.

## Примеры тест-кейсов для существующего функционала
### Модуль `masks`
#### 1. Функция `get_mask_card_number`:
- Тестирование правильности маскирования номера карты.
- Проверка работы функции на различных входных форматах номеров карт, включая граничные случаи и нестандартные длины номеров.
- Проверка, что функция корректно обрабатывает входные строки, где отсутствует номер карты.
#### 2. Функция `get_mask_account`:
- Тестирование правильности маскирования номера счета.
- Проверка работы функции с различными форматами и длинами номеров счетов.
- Проверка, что функция корректно обрабатывает входные данные, где номер счета меньше ожидаемой длины.
### **Модуль `widget`**
#### 1. **Функция** `mask_account_card`:
- Тесты для проверки, что функция корректно распознает и применяет нужный тип маскировки в зависимости 
от типа входных данных (карта или счет).
- Параметризованные тесты с разными типами карт и счетов для проверки универсальности функции.
- Тестирование функции на обработку некорректных входных данных и проверка ее устойчивости к ошибкам.
#### 2. **Функция** `get_date`:
- Тестирование правильности преобразования даты.
- Проверка работы функции на различных входных форматах даты, включая граничные случаи и нестандартные 
строки с датами.
- Проверка, что функция корректно обрабатывает входные строки, где отсутствует дата.
### **Модуль `processing`**
#### 1. **Функция** `filter_by_state`:
- Тестирование фильтрации списка словарей по заданному статусу `state`.
- Проверка работы функции при отсутствии словарей с указанным статусом `state`в списке.
- Параметризация тестов для различных возможных значений статуса `state`.
#### 2. **Функция** `sort_by_date`:
- Тестирование сортировки списка словарей по датам в порядке убывания и возрастания.
- Проверка корректности сортировки при одинаковых датах. 
- Тесты на работу функции с некорректными или нестандартными форматами дат.
### Общие аспекты тестирования
- **`Фикстуры`**. Для всех тестов создайте `фикстуры`, которые предоставят тестовые данные для списков словарей, 
включая различные случаи и комбинации `state`и `date`.
- **Покрытие тестами**. Убедитесь, что все ветви кода и исключения, которые могут быть сгенерированы вашими функциями, 
тестируются.

### 2. Примените `фикстуры` для создания необходимых входных данных для тестов.
### 3. Используйте параметризацию в тестах для обеспечения тестирования функциональности с различными входными данными, избегайте дублирования кода.
### 4. Добейтесь покрытия тестами не менее 80% кода.